name: Deploy to Development

on:
  push:
    branches: [dev]
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: development
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Extract project name
        id: project
        run: |
          # Extract APP_NAME from .env.example or .env
          if [ -f .env.example ]; then
            APP_NAME=$(grep "^APP_NAME=" .env.example | cut -d'=' -f2)
          elif [ -f .env ]; then
            APP_NAME=$(grep "^APP_NAME=" .env | cut -d'=' -f2)
          else
            echo "Error: No .env or .env.example file found"
            exit 1
          fi
          
          # Use GitHub secret if provided, otherwise use extracted name
          if [ -n "${{ secrets.APP_NAME }}" ]; then
            APP_NAME="${{ secrets.APP_NAME }}"
          fi
          
          echo "app_name=${APP_NAME}" >> $GITHUB_OUTPUT
          echo "Project name: ${APP_NAME}"

      - name: Install doctl
        uses: digitalocean/action-doctl@v2
        with:
          token: ${{ secrets.DO_ACCESS_TOKEN }}

      - name: Manage Droplet
        id: droplet
        run: |
          DROPLET_NAME="${{ steps.project.outputs.app_name }}-dev"
          
          # Check if droplet exists
          if doctl compute droplet list --format Name | grep -q "^${DROPLET_NAME}$"; then
            echo "Droplet exists, getting IP..."
            IP=$(doctl compute droplet get ${DROPLET_NAME} --format PublicIPv4 --no-header)
          else
            echo "Creating new droplet..."
            doctl compute droplet create ${DROPLET_NAME} \
              --image docker-20-04 \
              --size s-2vcpu-4gb \
              --region ${{ secrets.DO_REGION || 'nyc1' }} \
              --ssh-keys ${{ secrets.DO_SSH_KEY_FINGERPRINT }} \
              --tag-names dev,automated,ventum \
              --user-data-file=- <<'EOF'
          #!/bin/bash
          apt-get update
          apt-get install -y docker.io docker-compose git nginx certbot python3-certbot-nginx
          systemctl start docker
          systemctl enable docker
          
          # Setup swap for better memory management
          fallocate -l 2G /swapfile
          chmod 600 /swapfile
          mkswap /swapfile
          swapon /swapfile
          echo '/swapfile none swap sw 0 0' >> /etc/fstab
          
          # Setup firewall
          ufw allow 22/tcp
          ufw allow 80/tcp
          ufw allow 443/tcp
          ufw allow 3000/tcp
          ufw allow 5173/tcp
          ufw --force enable
          EOF
            
            # Wait for droplet to be ready
            sleep 60
            IP=$(doctl compute droplet get ${DROPLET_NAME} --format PublicIPv4 --no-header)
          fi
          
          echo "ip=${IP}" >> $GITHUB_OUTPUT
          echo "Droplet IP: ${IP}"

      - name: Wait for SSH
        run: |
          # Create SSH key file
          echo "${{ secrets.DO_SSH_PRIVATE_KEY }}" > /tmp/ssh_key
          chmod 600 /tmp/ssh_key
          
          for i in {1..30}; do
            if ssh -o StrictHostKeyChecking=no -o ConnectTimeout=5 \
               -i /tmp/ssh_key \
               root@${{ steps.droplet.outputs.ip }} "echo connected"; then
              echo "SSH connection established"
              break
            fi
            echo "Waiting for SSH... (attempt $i/30)"
            sleep 10
          done
          
          # Clean up SSH key file
          rm -f /tmp/ssh_key

      - name: Deploy Application
        uses: appleboy/ssh-action@v1.0.0
        env:
          APP_NAME: ${{ steps.project.outputs.app_name }}
          NODE_ENV: development
          POSTGRES_DB: ${{ secrets.DEV_POSTGRES_DB }}
          POSTGRES_USER: ${{ secrets.DEV_POSTGRES_USER }}
          POSTGRES_PASSWORD: ${{ secrets.DEV_POSTGRES_PASSWORD }}
          COOKIE_SECRET: ${{ secrets.DEV_COOKIE_SECRET }}
          GOOGLE_CLIENT_ID: ${{ secrets.GOOGLE_AUTH_CLIENT_ID }}
          GOOGLE_CLIENT_SECRET: ${{ secrets.GOOGLE_AUTH_CLIENT_SECRET }}
          BACKEND_URL: http://${{ steps.droplet.outputs.ip }}:3000
          FRONTEND_URL: http://${{ steps.droplet.outputs.ip }}:5173
        with:
          host: ${{ steps.droplet.outputs.ip }}
          username: root
          key: ${{ secrets.DO_SSH_PRIVATE_KEY }}
          envs: APP_NAME,NODE_ENV,POSTGRES_DB,POSTGRES_USER,POSTGRES_PASSWORD,COOKIE_SECRET,GOOGLE_CLIENT_ID,GOOGLE_CLIENT_SECRET,BACKEND_URL,FRONTEND_URL
          script: |
            # Clone or update repository
            if [ -d "/app" ]; then
              cd /app
              git fetch origin
              git reset --hard origin/dev
            else
              git clone -b dev ${{ github.server_url }}/${{ github.repository }}.git /app
              cd /app
            fi
            
            # Create .env file
            cat > .env << EOL
            APP_NAME=${APP_NAME}
            NODE_ENV=${NODE_ENV}
            POSTGRES_DB=${POSTGRES_DB}
            POSTGRES_USER=${POSTGRES_USER}
            POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
            POSTGRES_HOST=postgres
            POSTGRES_PORT=5432
            DATABASE_URL=postgresql://${POSTGRES_USER}:${POSTGRES_PASSWORD}@postgres:5432/${POSTGRES_DB}
            COOKIE_SECRET=${COOKIE_SECRET}
            SESSION_EXPIRATION_MINUTES=120
            GOOGLE_CLIENT_ID=${GOOGLE_CLIENT_ID}
            GOOGLE_CLIENT_SECRET=${GOOGLE_CLIENT_SECRET}
            BACKEND_PORT=3000
            FRONTEND_PORT=5173
            FE_URL=${FRONTEND_URL}
            VITE_API_URL=${BACKEND_URL}
            EOL
            
            # Stop existing containers
            docker-compose down || true
            
            # Clean up Docker resources
            docker system prune -f
            
            # Build and start containers
            docker-compose up -d --build
            
            # Wait for database
            echo "Waiting for database..."
            for i in {1..30}; do
              if docker-compose exec -T postgres pg_isready -U ${POSTGRES_USER}; then
                echo "Database is ready"
                break
              fi
              sleep 2
            done
            
            # Run migrations
            docker-compose exec -T backend npm run migration:run || true
            
            # Health check
            sleep 10
            if curl -f http://localhost:3000/health; then
              echo "âœ… Backend is healthy"
            else
              echo "âŒ Backend health check failed"
              docker-compose logs backend
            fi

      - name: Setup Cloudflare DNS
        run: |
          # Install Node.js for the DNS script
          node scripts/cloudflare-dns.js update ${{ steps.project.outputs.app_name }} ${{ steps.droplet.outputs.ip }}
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ZONE_ID: ${{ secrets.CLOUDFLARE_ZONE_ID }}

      - name: Configure Nginx with SSL
        uses: appleboy/ssh-action@v1.0.0
        env:
          DOMAIN: ${{ steps.project.outputs.app_name }}.dev.ventum.dev
          ADMIN_EMAIL: ${{ secrets.ADMIN_EMAIL }}
        with:
          host: ${{ steps.droplet.outputs.ip }}
          username: root
          key: ${{ secrets.DO_SSH_PRIVATE_KEY }}
          envs: DOMAIN,ADMIN_EMAIL
          script: |
            # Wait for DNS propagation
            echo "Waiting for DNS propagation..."
            sleep 60
            
            # Configure Nginx
            cat > /etc/nginx/sites-available/default << EOF
            server {
                listen 80;
                server_name ${DOMAIN} www.${DOMAIN};
                
                # Redirect HTTP to HTTPS
                return 301 https://\$host\$request_uri;
            }
            
            server {
                listen 443 ssl http2;
                server_name ${DOMAIN} www.${DOMAIN};
                
                # SSL Configuration (will be managed by Certbot)
                ssl_certificate /etc/letsencrypt/live/${DOMAIN}/fullchain.pem;
                ssl_certificate_key /etc/letsencrypt/live/${DOMAIN}/privkey.pem;
                include /etc/letsencrypt/options-ssl-nginx.conf;
                ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem;
                
                # Frontend
                location / {
                    proxy_pass http://localhost:5173;
                    proxy_http_version 1.1;
                    proxy_set_header Upgrade \$http_upgrade;
                    proxy_set_header Connection 'upgrade';
                    proxy_set_header Host \$host;
                    proxy_cache_bypass \$http_upgrade;
                    proxy_set_header X-Real-IP \$remote_addr;
                    proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
                    proxy_set_header X-Forwarded-Proto \$scheme;
                }
                
                # Backend API
                location /api {
                    proxy_pass http://localhost:3000;
                    proxy_http_version 1.1;
                    proxy_set_header Upgrade \$http_upgrade;
                    proxy_set_header Connection 'upgrade';
                    proxy_set_header Host \$host;
                    proxy_cache_bypass \$http_upgrade;
                    proxy_set_header X-Real-IP \$remote_addr;
                    proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
                    proxy_Set_header X-Forwarded-Proto \$scheme;
                }
                
                # Health check endpoint
                location /health {
                    proxy_pass http://localhost:3000/health;
                    proxy_set_header Host \$host;
                    proxy_set_header X-Real-IP \$remote_addr;
                    proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
                }
            }
            EOF
            
            # Get SSL certificate with Certbot
            certbot --nginx --non-interactive --agree-tos --email ${ADMIN_EMAIL} -d ${DOMAIN}
            
            # Test and reload Nginx
            nginx -t && systemctl reload nginx
            
            # Setup auto-renewal
            systemctl enable certbot.timer

      - name: Output Deployment Info
        run: |
          DOMAIN="${{ steps.project.outputs.app_name }}.dev.ventum.dev"
          echo "## ðŸš€ Development Deployment Successful!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸŒ Custom Domain (with SSL):" >> $GITHUB_STEP_SUMMARY
          echo "- **Application**: https://${DOMAIN}" >> $GITHUB_STEP_SUMMARY
          echo "- **API**: https://${DOMAIN}/api" >> $GITHUB_STEP_SUMMARY
          echo "- **Health Check**: https://${DOMAIN}/health" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ“¡ Direct IP Access:" >> $GITHUB_STEP_SUMMARY
          echo "- **Droplet IP**: ${{ steps.droplet.outputs.ip }}" >> $GITHUB_STEP_SUMMARY
          echo "- Frontend: http://${{ steps.droplet.outputs.ip }}:5173" >> $GITHUB_STEP_SUMMARY
          echo "- Backend: http://${{ steps.droplet.outputs.ip }}:3000" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ”§ SSH Access:" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`bash" >> $GITHUB_STEP_SUMMARY
          echo "ssh root@${{ steps.droplet.outputs.ip }}" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### âš¡ Features:" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Custom subdomain: ${DOMAIN}" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… SSL certificate via Let's Encrypt" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Cloudflare CDN & DDoS protection" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Auto-renewal enabled" >> $GITHUB_STEP_SUMMARY